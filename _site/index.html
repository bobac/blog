<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/assets/css/styles.css">
    <link type="application/atom+xml" rel="alternate" href="/feed.xml" />
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Bobáčův blbník</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="Bobáčův blbník" />
<meta property="og:locale" content="en_US" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Bobáčův blbník" />
<script type="application/ld+json">
{"url":"/","headline":"Bobáčův blbník","@type":"WebSite","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <title>Bobáčův blbník</title>
</head>
<body>
    <nav>
  
    <a href="/" class="current">
        Bobáčův blbník
    </a>
  
    <a href="/about.html" >
        Něco o mě
    </a>
  
</nav>
    <h1>Bobáčův blbník</h1>

<ul>
  
    <li>
      <h2><a href="/2021/12/01/docker-znovupouziti-image.html">Docker Compose - znovupoužití image, kterou buildovala jiná service</a></h2>
      <p>Potřeboval jsem <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>, který buildil image z <code class="language-plaintext highlighter-rouge">Dockerfile</code> místo toho, aby ji hotovou odněkud stahoval, nebo abych ji nemusel buildovat předtím já ručně pomocí <code class="language-plaintext highlighter-rouge">docker build...</code>. To je docela šikovná věc, zejména, pokud ta image je to, co zrovna vyvýjíte. <strong>Docker Compose</strong> na to má hezkou direktivu <code class="language-plaintext highlighter-rouge">build</code> místo tradiční <code class="language-plaintext highlighter-rouge">image</code>.</p>

    </li>
  
    <li>
      <h2><a href="/2021/11/23/lvm.html">Příparava LVM pro instalaci Linuxu</a></h2>
      <p>Experimentuji z Arch Linuxem. Hlavní důvod je, že se zdá, že Arch je cesta, jak pochopit, relativně do detailů, jak některé věci, které před námi “velké” distribuce jako Debian, Ubuntu, či třeba Fedora tají tím, že je tak nějak udělají za nás. V následujcím postu se pokusím popsat, co je třeba udělat k rozběhnutí <strong>Linuxu na LVM s GPT diskem a EFI</strong>.</p>

    </li>
  
    <li>
      <h2><a href="/2021/11/22/zmena-raid-na-ahci-windows-10.html">Změna SATA RAID mode na AHCI a nebootující Windows 10</a></h2>
      <p>Potřeboval jsem u svého stárnoucího <strong>Dell OptiPLex 3050</strong> změnit v BIOSu režim SATA disku z RAID na AHCI. Potřeboval jsem to proto, že primární disk je NVME, na něm jsou <strong>Windows 10</strong>, a na druhém (SATA) mám <strong>Ubuntu 20.04</strong>. Potřebuji z Linuxu vidět na Windowsí disk a gůglením jsem zjistil, že důvod, proč žádné <code class="language-plaintext highlighter-rouge">/dev/nvme*</code> nevidím není v tom, že by můj kernel 5.4.xx NVME nepodporoval, NVME je podporováno už od kernelu 3.3, ale v tom, že kernel nevidí NVME disk, když je v BIOSu nastavený SATA RAID mode.</p>

    </li>
  
    <li>
      <h2><a href="/2021/11/19/Jak-nastavit-Windows-hodiny-na-UTC.html">Jak nastavit Windows, aby braly hodiny v počítači dle UTC</a></h2>
      <p>Občas je třeba, aby RTC hodiny v počítači byly nastaveny na <em>UTC</em>, ale aby Windows ukazovaly čas dle naší časové zóny, tedy <em>local time</em>. Hodí se to třeba v případě, že provozujete dual boot Windows a Linux. Obecně je totiž zvykem, že Windows očekávají, že jsou hodiny v počítači nastaveny na místní čas, kdežto Linux očekává, že hodiny v počítači jsou nastaveny na UTC.</p>

    </li>
  
    <li>
      <h2><a href="/2021/11/19/Clonezilla-MBR-GPT-Mismatch-error.html">Clonezilla - divná chyba MBR a GPT mismatch</a></h2>
      <p>Experimentoval jsem s <a href="https://clonezilla.org/">Clonezillou</a>. Nainstaloval jsem čisté <strong>Windows 10 Pro</strong> na disk, kde už předtím nějaká Win10 byla. Nicméně jsem v setupu na začátku vykilloval všechny partition a do prázdného místa nainstaloval Windows znovu. Po tradičním zapatchování jsem chtěl Clonezillou udělat image celého disku. Po odbouchání next - next - next víceméně s defaultním nastavením na mě vypadla divná chyba, něco jako <em>“this disk contains mismatched gpt and mbr”</em> a imagování crashlo ještě dřív, než začalo.</p>

    </li>
  
    <li>
      <h2><a href="/2021/11/17/Tagy-na-mp3-z-cli.html">Tagy na MP3 z CLI</a></h2>
      <p>Před chvílí jsem zjitil, že potřebuji z command lajny na linuxovém serveru upravovat tagy pro MP3 soubory. Po chvíli googlení jsem přistál u <code class="language-plaintext highlighter-rouge">mid3v2</code>. Hlavní důvod je, že by měl podporovat <strong>utf-8</strong>.</p>

    </li>
  
    <li>
      <h2><a href="/2021/11/17/Navidrome-self-hosted-music-streaming.html">Navidrome - self hosted music streaming</a></h2>
      <p>V minulém <a href="/2021/11/17/Tagy-na-mp3-z-cli.html">blogu</a> jsem psal o <strong>mid3v2</strong> k editování MP3 Tagů z CLI. Potřeboval jsem si rozběhnout vlastní streamování MP3, které bude mimo iTunes. Jde o to, že mám pár audioknih, které jsem koupil u <a href="https://kechlibar.net/obchod/">Mariana Kechlibara</a>, a které jsem potřeboval oddělit od iTunes. Důvod je poměrně jednoduchý - chci, abych měl rozposlouchanou knihu někde jinde než muziku, z toho prostého důvodu, že iTunes nemá žádné záložky, takže jakmile pustím nějakou hudbu, prd vím, kde jsem přestal poslouchat knížku :-)</p>

    </li>
  
    <li>
      <h2><a href="/2021/11/05/reverzni-proxy-s-ntlm.html">Reverzní proxy s NTLM</a></h2>
      <p>Už před časem jsem narazil na to, že pokud potřebuju někde udělat reverzní proxy, která potřebuje podporu NTLM authentication, tak mám se svým NGINXem smůlu. NGINX totiž podporuje NTLM pouze v placené verzi. Nějakou dobu registruji existenci web serveru <strong><a href="https://caddyserver.com/">Caddy</a></strong>, ale zatím jsem si vždy vystačil s kombem <a href="https://www.nginx.com/">NGINX</a> a geniálním, krásným, a vůbec po všech stránkách velmi povedeným <a href="https://nginxproxymanager.com/">Nginx Proxy Managerem</a>. Důvod, proč jsem vždycky používal <strong>NGINX</strong> (třeba namísto Apache) byl v tom, že mi styl konfigurace tak nějak šel lépe do ruky. Nějakou dobu jsem řešil <strong>Let’s Encrypt</strong> certifikáty pomocí jejich skriptů a fungovalo to docela hezky, ale <strong>Nginx Proxy Manager</strong> to ještě dost zjednodušil - prostě si zaškrtnete, že k danému webu chcete https, necháte jej <em>HTTP</em> traffic automaticky forwardovat na <em>HTTPS</em> a o víc se nemusíte starat. Běží to ve dvou kontejnerech, má to hezké klikací webové rozhraní a generujete konfiguráky pro <strong>NGINX</strong> samo. A taky to samo obnovuje certifikáty. Nádhera! Vypadá to asi takhle:</p>

    </li>
  
    <li>
      <h2><a href="/2021/10/31/jekyll.html">Jekyll</a></h2>
      <p>Tenhle blbník běží na <a href="https://jekyllrb.com">Jekyllu</a>. Pohrávám si s myšlenkou, že to vůbec nebudu stylovat nechám to takhle hnusný. Čistej defaultní html layout jako z devadesátek, tesně před tím, než lidé přišli na to, že je možný přidělat nějkaý blikátka. Pamatujete si taky na ty hnusný animovaný GIFy?</p>

    </li>
  
</ul>
</body>
</html>